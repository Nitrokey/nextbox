"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractModulesPackages = void 0;
const max_1 = __importDefault(require("lodash/max"));
const last_1 = __importDefault(require("lodash/last"));
const uniqBy_1 = __importDefault(require("lodash/uniqBy"));
const config_1 = require("../../config");
const PACKAGE_NAMES = /(node_modules|~)\/((!?@(([\w|\-|_|.]*)\/){2})|(([\w|\-|_|.]*)\/))/g;
const getPackageInfoFromModulePath = (moduleName) => {
    const found = moduleName.match(PACKAGE_NAMES);
    if (!found) {
        return null;
    }
    const names = found.map((modulePath) => modulePath.replace(/.*(node_modules|~)\/(.*)\/$/, '$2'));
    const pattern = new RegExp(`(.*)(${last_1.default(found)}).*`);
    const path = moduleName.replace(pattern, '$1$2').replace(/\/$/, '');
    return {
        name: names.join(config_1.PACKAGES_SEPARATOR),
        path,
    };
};
const extractModulesPackages = (webpackStats, currentExtractedData) => {
    var _a;
    const modulesByChunks = ((_a = currentExtractedData === null || currentExtractedData === void 0 ? void 0 : currentExtractedData.metrics) === null || _a === void 0 ? void 0 : _a.modules) || {};
    const modules = uniqBy_1.default(Object.values(modulesByChunks).map((chunk) => Object.entries(chunk.modules)).flat(), ([id]) => id);
    const packages = modules.reduce((agg, [modulePath, { value }]) => {
        const packageInfo = getPackageInfoFromModulePath(modulePath);
        if (!packageInfo) {
            return agg;
        }
        const existingPackageData = agg[packageInfo.name];
        if (!existingPackageData) {
            return {
                ...agg,
                [packageInfo.name]: {
                    path: packageInfo.path,
                    value,
                }
            };
        }
        if (existingPackageData.path === packageInfo.path) {
            return {
                ...agg,
                [packageInfo.name]: {
                    ...existingPackageData,
                    value: existingPackageData.value + value,
                },
            };
        }
        const existingPackageWithEqualPath = Object.entries(agg).find(([_, packageData]) => packageData.path === packageInfo.path);
        if (existingPackageWithEqualPath) {
            const [name, data] = existingPackageWithEqualPath;
            return {
                ...agg,
                [name]: {
                    ...data,
                    value: data.value + value,
                },
            };
        }
        const lastIndex = max_1.default(Object.keys(agg)
            .map((name) => name.split('~'))
            .filter(([name]) => name === packageInfo.name)
            .map(([_, index]) => parseInt(index, 10))) || 0;
        const packageName = [packageInfo.name, lastIndex + 1].join(config_1.PACKAGE_ID_SEPARATOR);
        return {
            ...agg,
            [packageName]: {
                path: packageInfo.path,
                value,
            },
        };
    }, {});
    return { metrics: { packages } };
};
exports.extractModulesPackages = extractModulesPackages;
//# sourceMappingURL=modules-packages.js.map