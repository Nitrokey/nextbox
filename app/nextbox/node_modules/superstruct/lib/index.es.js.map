{"version":3,"file":"index.es.js","sources":["../node_modules/kind-of/index.js","../src/types.ts","../node_modules/tiny-invariant/dist/tiny-invariant.esm.js","../src/struct-error.ts","../src/struct.ts","../src/structs/array.ts","../src/structs/dynamic.ts","../src/structs/enum.ts","../src/structs/function.ts","../src/structs/instance.ts","../src/structs/interface.ts","../src/structs/intersection.ts","../src/structs/lazy.ts","../src/structs/size.ts","../src/structs/literal.ts","../src/structs/object.ts","../src/structs/partial.ts","../src/structs/pick.ts","../src/structs/record.ts","../src/structs/scalar.ts","../src/structs/shorthand.ts","../src/structs/tuple.ts","../src/structs/union.ts","../src/superstruct.ts","../src/index.ts"],"sourcesContent":["var toString = Object.prototype.toString;\n\nmodule.exports = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return typeof val.constructor === 'function' ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n","import kindOf from 'kind-of'\nimport { Branch, Path, Failure } from './struct-error'\n\n/**\n * Superstruct ships by default with an unopinionated set of scalar types that\n * express all of the data types that are built-in to JavaScript.\n */\n\nexport const Types = {\n  /**\n   * Matches any value other than `undefined`.\n   *\n   * ```js\n   * 'anything'\n   * true\n   * ```\n   */\n\n  any: (value: any) => value !== undefined,\n\n  /**\n   * Matches an `arguments` object.\n   *\n   * ```js\n   * arguments\n   * ```\n   */\n\n  arguments: (value: any) => kindOf(value) === 'arguments',\n\n  /**\n   * Matches an `Array`.\n   *\n   * ```js\n   * [1, 2, 3]\n   * ```\n   */\n\n  array: (value: any) => kindOf(value) === 'array',\n\n  /**\n   * Matches a boolean.\n   *\n   * ```js\n   * true\n   * false\n   * ```\n   */\n\n  boolean: (value: any) => kindOf(value) === 'boolean',\n\n  /**\n   * Matches a Node.js `Buffer`.\n   *\n   * ```js\n   * Buffer.from('string')\n   * ```\n   */\n\n  buffer: (value: any) => kindOf(value) === 'buffer',\n\n  /**\n   * Matches a **valid** `Date` object.\n   *\n   * ```js\n   * new Date()\n   * ```\n   *\n   * Note: Invalid `Date` objects that equal `NaN` are not matched.\n   */\n\n  date: (value: any) => kindOf(value) === 'date' && !isNaN(value),\n\n  /**\n   * Matches an error object.\n   *\n   * ```js\n   * new Error()\n   * ```\n   */\n\n  error: (value: any) => kindOf(value) === 'error',\n\n  /**\n   * Matches a `Float32Array` object.\n   */\n\n  float32array: (value: any) => kindOf(value) === 'float32array',\n\n  /**\n   * Matches a `Float64Array` object.\n   */\n\n  float64array: (value: any) => kindOf(value) === 'float64array',\n\n  /**\n   * Matches a function.\n   *\n   * ```js\n   * () => {}\n   * function () {}\n   * ```\n   */\n\n  function: (value: any) => kindOf(value) === 'function',\n\n  /**\n   * Matches a generator function.\n   *\n   * ```js\n   * function* () {}\n   * ```\n   */\n\n  generatorfunction: (value: any) => kindOf(value) === 'generatorfunction',\n\n  /**\n   * Matches a `Int16Array` object.\n   */\n\n  int16array: (value: any) => kindOf(value) === 'int16array',\n\n  /**\n   * Matches a `Int32Array` object.\n   */\n\n  int32array: (value: any) => kindOf(value) === 'int32array',\n\n  /**\n   * Matches a `Int8Array` object.\n   */\n\n  int8array: (value: any) => kindOf(value) === 'int8array',\n\n  /**\n   * Matches a `Map` object.\n   *\n   * ```js\n   * new Map()\n   * ```\n   */\n\n  map: (value: any) => kindOf(value) === 'map',\n\n  /**\n   * Matches the `null` literal value.\n   *\n   * ```js\n   * null\n   * ```\n   */\n\n  null: (value: any) => kindOf(value) === 'null',\n\n  /**\n   * Matches a number.\n   *\n   * ```js\n   * 42\n   * ```\n   */\n\n  number: (value: any) => kindOf(value) === 'number',\n\n  /**\n   * Matches a plain object.\n   *\n   * ```js\n   * { key: 'value' }\n   * { something: true }\n   * ```\n   */\n\n  object: (value: any) => kindOf(value) === 'object',\n\n  /**\n   * Matches a `Promise` object.\n   *\n   * ```js\n   * Promise.resolve()\n   * ```\n   */\n\n  promise: (value: any) => kindOf(value) === 'promise',\n\n  /**\n   * Matches a regular expression object.\n   *\n   * ```js\n   * /a-z/g\n   * ```\n   */\n\n  regexp: (value: any) => kindOf(value) === 'regexp',\n\n  /**\n   * Matches a `Set` object.\n   *\n   * ```js\n   * new Set()\n   * ```\n   */\n\n  set: (value: any) => kindOf(value) === 'set',\n\n  /**\n   * Matches a string.\n   *\n   * ```js\n   * 'text'\n   * ```\n   */\n\n  string: (value: any) => kindOf(value) === 'string',\n\n  /**\n   * Matches a `Symbol`.\n   *\n   * ```js\n   * Symbol()\n   * ```\n   */\n\n  symbol: (value: any) => kindOf(value) === 'symbol',\n\n  /**\n   * Matches a `Uint16Array` object.\n   */\n\n  uint16array: (value: any) => kindOf(value) === 'uint16array',\n\n  /**\n   * Matches a `Uint32Array` object.\n   */\n\n  uint32array: (value: any) => kindOf(value) === 'uint32array',\n\n  /**\n   * Matches a `Uint8Array` object.\n   */\n\n  uint8array: (value: any) => kindOf(value) === 'uint8array',\n\n  /**\n   * Matches a `Uint8ClampedArray` object.\n   */\n\n  uint8clampedarray: (value: any) => kindOf(value) === 'uint8clampedarray',\n\n  /**\n   * Matches the `undefined` literal value.\n   *\n   * ```js\n   * undefined\n   * ```\n   */\n\n  undefined: (value: any) => kindOf(value) === 'undefined',\n\n  /**\n   * Matches a `WeakMap` object.\n   *\n   * ```js\n   * new WeakMap()\n   * ```\n   */\n\n  weakmap: (value: any) => kindOf(value) === 'weakmap',\n\n  /**\n   * Matches a `WeakSet` object.\n   *\n   * ```js\n   * new WeakSet()\n   * ```\n   */\n\n  weakset: (value: any) => kindOf(value) === 'weakset',\n}\n\n/**\n * `Validator` functions allow developers to define their own scalar types for\n * Superstruct to validate against, and return an indication of what is invalid.\n *\n * ```js\n * import { superstruct } from 'superstruct'\n * import isEmail from 'is-email'\n *\n * const struct = superstruct({\n *   types: {\n *     email: value => isEmail(value) && value.length < 256,\n *   }\n * })\n * ```\n */\n\nexport type Validator = (\n  value: any,\n  branch: Branch,\n  path: Path\n) => Partial<Failure>[] | Partial<Failure> | boolean\n","var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n  if (condition) {\n    return;\n  }\n\n  if (isProduction) {\n    throw new Error(prefix);\n  } else {\n    throw new Error(prefix + \": \" + (message || ''));\n  }\n}\n\nexport default invariant;\n","import invariant from 'tiny-invariant'\n\n/**\n * `StructError` objects are thrown (or returned) by Superstruct when its\n * validation fails. The error represents the first error encountered during\n * validation. But they also have an `error.failures` property that holds\n * information for all of the failures encountered.\n */\n\nexport class StructError extends TypeError {\n  branch: Branch\n  failures: Failure[]\n  path: Path\n  type: string | undefined\n  value: any\n  [key: string]: any\n\n  constructor(failures: Failure[]) {\n    invariant(\n      failures.length > 0,\n      `StructError requires being passed a failure, but received: ${failures}`\n    )\n\n    const [first] = failures\n    const { path, value, type, branch, ...rest } = first\n    const message = `Expected a value of type \\`${type}\\`${\n      path.length ? ` for \\`${path.join('.')}\\`` : ''\n    } but received \\`${JSON.stringify(value)}\\`.`\n\n    super(message)\n    this.type = type\n    this.value = value\n    Object.assign(this, rest)\n    this.path = path\n    this.branch = branch\n    this.failures = failures\n    this.stack = new Error().stack\n    ;(this as any).__proto__ = StructError.prototype\n  }\n}\n\n/**\n * `Path` arrays specify a nested value's location in a root object or array.\n *\n * ```js\n * ['user', 'address', 'city']\n * ['nodes', 1, 'nodes', 0, 'text']\n * ```\n */\n\nexport type Path = Array<number | string>\n\n/**\n * `Branch` arrays contain each value following a path down from the root.\n *\n * ```js\n * [root, ..., parent, value]\n * ```\n */\n\nexport type Branch = Array<any>\n\n/**\n * `Failure` objects represent a specific failure in validation. They are plain\n * objects that can be turned into real `StructError` when needed.\n *\n * ```js\n * {\n *   type: 'number',\n *   value: 'invalid',\n *   path: [1],\n *   branch: [\n *     [1, 'invalid', 2],\n *     'invalid',\n *   ]\n * }\n */\n\nexport type Failure = {\n  /**\n   * The branch of values following a path down from the root.\n   */\n\n  branch: Branch\n\n  /**\n   * The path of indices to retrieve the failing value from the root.\n   */\n\n  path: Path\n\n  /**\n   * The failing value.\n   */\n\n  value: any\n\n  /**\n   * The expected type description of the failing value, or `undefined` if it\n   * didn't have an expected type.\n   */\n\n  type: string | undefined\n\n  /**\n   * Failures can also be augmented with any of your on custom properties.\n   */\n\n  [key: string]: any\n}\n","import { Failure, Branch, Path } from './struct-error'\nimport { Superstruct } from './superstruct'\n\n/**\n * A symbol to set on `Struct` objects to test them against later.\n */\n\nexport const STRUCT = Symbol('STRUCT')\n\n/**\n * Check if a value is a `Struct` object.\n */\n\nexport const isStruct = (value: any): value is Struct => {\n  return typeof value === 'function' && value[STRUCT]\n}\n\n/**\n * This abstract `Struct` factory creates a generic struct that validates values\n * against a `Validator` function.\n */\n\nexport const createStruct = (props: {\n  kind: string\n  type: string\n  defaults: () => any\n  struct: Superstruct\n}): Struct => {\n  const { struct } = props\n  const { Error } = struct\n  const Struct = (value: any): any => Struct.assert(value)\n\n  // Set a hidden symbol property so that we can check it later to see if an\n  // object is a struct object.\n  Object.defineProperty(Struct, STRUCT, { value: true })\n\n  Struct.kind = props.kind\n  Struct.type = props.type\n\n  Struct.default = () => {\n    return typeof props.defaults === 'function'\n      ? props.defaults()\n      : props.defaults\n  }\n\n  Struct.test = (value: any): boolean => {\n    const [failures] = Struct.check(value, [value], [])\n    return !failures\n  }\n\n  Struct.assert = (value: any): any => {\n    const [failures, result] = Struct.check(value, [value], [])\n\n    if (failures) {\n      throw new Error(failures)\n    } else {\n      return result\n    }\n  }\n\n  Struct.validate = (value: any): [Error?, any?] => {\n    const [failures, result] = Struct.check(value, [value], [])\n\n    if (failures) {\n      return [new Error(failures)]\n    } else {\n      return [undefined, result]\n    }\n  }\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const failures = [Struct.fail({ value, branch, path })]\n    return [failures]\n  }\n\n  Struct.fail = (obj: {\n    value: any\n    branch: Branch\n    path: Path\n    type?: string\n  }): Failure => {\n    return { ...obj, type: 'type' in obj ? obj.type : Struct.type }\n  }\n\n  return Struct\n}\n\n/**\n * `Struct` validators encapsulate the validation logic for a specific type of\n * data (either custom or built-in). They have a set of methods that allow you\n * to validate input in various ways, while producing detailed errors.\n *\n * They are created by the [[Superstruct]] factory functions. You can call them\n * directly for the simple case, or use one of their validation methods.\n *\n * ```js\n * const Struct = struct({\n *   id: 'number',\n *   name: 'string',\n * })\n *\n * const result = Struct(data) // Throws if invalid!\n *\n * const [error, result] = Struct.validate(data)\n *\n * if (Struct.test(data)) {\n *    // ...\n * }\n * ```\n */\n\nexport interface Struct {\n  /**\n   * All structs are functions that are shorthand for calling [[Struct.assert]].\n   */\n\n  (value: any): any\n\n  /**\n   * The struct's name.\n   *\n   * ```js\n   * 'object'\n   * 'union'\n   * 'email'\n   * ```\n   */\n\n  kind: string\n\n  /**\n   * A string representing the type of the struct. These strings are purely for\n   * user-facing error messages, and aren't canonical. They are similar to the\n   * syntax that TypeScript uses.\n   *\n   * ```js\n   * '{id,name,email}'\n   * 'string | number'\n   * 'email'\n   * ```\n   */\n\n  type: string\n\n  /**\n   * Get the default value for a struct.\n   *\n   * ```js\n   * const defaults = Struct.default()\n   * ```\n   */\n\n  default(): any\n\n  /**\n   * Run the low-level validation function a struct, returning a tuple that\n   * contains either a list of [[Failure]] objects, or a resulting value.\n   *\n   * This method is fairly low-level and not for normal use.\n   *\n   * ```js\n   * const [failures, result] = Struct.check(value, branch, path)\n   * ```\n   */\n\n  check(value: any, branch: Branch, path: Path): [Failure[]?, any?]\n\n  /**\n   * Validate a `value`, returning the resulting value, and throwing an error if\n   * validation fails.\n   *\n   * ```js\n   * try {\n   *   const result = Struct.assert(value)\n   *   // ...\n   * } catch (e) {\n   *   // ...\n   * }\n   * ```\n   */\n\n  assert(value: any): any\n\n  /**\n   * Validate a `value`, returning a boolean indicating whether it's valid.\n   *\n   * Note: Using this method does not give you access to the defaults that may\n   * be associated with a struct, so it doesn't guarantee that the value you\n   * have passes, just that the value with defaults passes.\n   *\n   * ```js\n   * if (Struct.test(value)) {\n   *   // ...\n   * }\n   * ```\n   */\n\n  test(value: any): boolean\n\n  /**\n   * Validate a `value` returning a tuple containing an error if the validation\n   * fails, or the resulting value if it succeeds.\n   *\n   * ```js\n   * const [error, result] = Struct.validate(value)\n   * ```\n   */\n\n  validate(value: any): [Error?, any?]\n\n  /**\n   * Create a low-level [[Failure]] object for the struct.\n   *\n   * ```js\n   * const failure = Struct.fail({ value, branch, path })\n   * ```\n   */\n\n  fail(obj: { value: any; branch: Branch; path: Path; type?: string }): Failure\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createArray = (\n  schema: [any],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) && schema.length === 1,\n    `Array structs must be defined as an array with one element, but you passed: ${schema}`\n  )\n\n  const Element = struct(schema[0], undefined)\n  const Struct = createStruct({\n    kind: 'array',\n    type: `${Element.type}[]`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    if (!Array.isArray(value)) {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = []\n    const failures: Failure[] = []\n\n    for (let i = 0; i < value.length; i++) {\n      const v = value[i]\n      const [efs, er] = Element.check(v, branch.concat(v), path.concat(i))\n\n      if (efs) {\n        failures.push(...efs)\n        continue\n      }\n\n      result[i] = er\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createDynamic = (\n  schema: (value: any, branch: Branch, path: Path) => Struct,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'function',\n    `Dynamic structs must be defined as a function, but you passed: ${schema}`\n  )\n\n  const Dynamic = createStruct({\n    kind: 'dynamic',\n    type: `dynamic<…>`,\n    defaults,\n    struct,\n  })\n\n  Dynamic.check = (\n    value: any = Dynamic.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const Struct = schema(value, branch, path)\n    return Struct.check(value, branch, path)\n  }\n\n  return Dynamic\n}\n","import invariant from 'tiny-invariant'\nimport { Struct, Superstruct } from '..'\n\nexport const createEnum = (\n  schema: any[],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema),\n    `Enum structs must be defined as an array, but you passed: ${schema}`\n  )\n\n  const validator = (value: any) => schema.includes(value)\n  const Struct = struct(validator, defaults)\n  Struct.kind = 'enum'\n  Struct.type = schema\n    .map(s => (typeof s === 'string' ? `\"${s}\"` : `${s}`))\n    .join(' | ')\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct, Validator } from '..'\nimport { createStruct } from '../struct'\n\nexport const createFunction = (\n  schema: Validator,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  const Struct = createStruct({\n    kind: 'function',\n    type: `function<…>`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const result = schema(value, branch, path)\n\n    if (result === true) {\n      return [undefined, value]\n    }\n\n    const failures: Failure[] = []\n\n    if (result === false) {\n      failures.push(Struct.fail({ value, branch, path }))\n    } else if (Array.isArray(result) && result.length > 0) {\n      for (const r of result) {\n        failures.push(Struct.fail({ value, branch, path, ...r }))\n      }\n    } else if (typeof result === 'object') {\n      failures.push(Struct.fail({ value, branch, path, ...result }))\n    } else {\n      invariant(\n        false,\n        `Validator functions must return a boolean, a failure object, or an array of failure objects, but you passed: ${result}`\n      )\n    }\n\n    return [failures]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Struct, Superstruct } from '..'\n\nexport const createInstance = (\n  schema: any,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'function',\n    `Instance structs must be defined as a function, but you passed: ${schema}`\n  )\n\n  const validator = (value: any) => value instanceof schema\n  const Struct = struct(validator, defaults)\n  Struct.kind = 'instance'\n  Struct.type = `instance<${schema.name}>`\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createInterface = (\n  schema: any,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'object',\n    `Interface structs must be defined as an object, but you passed: ${schema}`\n  )\n\n  const Props: Record<string, Struct> = {}\n\n  for (const key in schema) {\n    Props[key] = struct(schema[key])\n  }\n\n  const Struct = createStruct({\n    kind: 'interface',\n    type: `interface<{${Object.keys(schema).join()}}>`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    if (typeof value !== 'object' && typeof value !== 'function') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const failures: Failure[] = []\n\n    for (const k in Props) {\n      const Prop = Props[k]\n      const v = value[k]\n      const [pfs] = Prop.check(v, branch.concat(v), path.concat(k))\n\n      if (pfs) {\n        failures.push(...pfs)\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, value]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createIntersection = (\n  schema: any[],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) && schema.length !== 0,\n    `Intersection structs must be defined as a non-empty array, but you passed: ${schema}`\n  )\n\n  const Structs = schema.map(sch => struct(sch))\n  const type = Structs.map(s => s.type).join(' & ')\n  const Struct = createStruct({\n    kind: 'intersection',\n    type,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    let result: any = value\n\n    for (const struct of Structs) {\n      const [fs, v] = struct.check(value, branch, path)\n\n      if (fs) {\n        return [[Struct.fail({ value, branch, path })]]\n      } else {\n        result = v\n      }\n    }\n\n    return [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Failure, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createLazy = (\n  schema: () => Struct,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'function',\n    `Lazy structs must be defined as a function, but you passed: ${schema}`\n  )\n\n  const Lazy = createStruct({\n    kind: 'lazy',\n    type: `lazy<…>`,\n    defaults,\n    struct,\n  })\n\n  Lazy.check = (...args): [Failure[]?, any?] => {\n    Object.assign(Lazy, schema())\n    return Lazy.check(...args)\n  }\n\n  return Lazy\n}\n","import invariant from 'tiny-invariant'\nimport { Struct, Superstruct } from '..'\n\nexport const createSize = (\n  schema: [number, number],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) &&\n      schema.length === 2 &&\n      schema.every(n => typeof n === 'number'),\n    `Size structs must be defined as an array with two number elements, but you passed: ${schema}`\n  )\n\n  const [min, max] = schema\n  const validator = (value: any) =>\n    value != null &&\n    typeof value.length === 'number' &&\n    value.length >= min &&\n    value.length <= max\n\n  const Struct = struct(validator, defaults)\n  Struct.kind = 'size'\n  Struct.type = `size<${min},${max}>`\n  return Struct\n}\n","import { Struct, Superstruct } from '..'\n\nexport const createLiteral = (\n  schema: any,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  const validator = (value: any) => value === schema\n  const Struct = struct(validator, defaults)\n  Struct.kind = 'literal'\n  Struct.type = typeof schema === 'string' ? `\"${schema}\"` : `${schema}`\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport kindOf from 'kind-of'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createObject = (\n  schema: {},\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'object',\n    `Object structs must be defined as an object, but you passed: ${schema}`\n  )\n\n  const Props: Record<string, Struct> = {}\n\n  for (const key in schema) {\n    Props[key] = struct(schema[key])\n  }\n\n  const Struct = createStruct({\n    kind: 'object',\n    type: `{${Object.keys(schema).join()}}`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const d = Struct.default()\n\n    if (value === undefined) {\n      value = d\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = {}\n    const failures: Failure[] = []\n    const keys = new Set(Object.keys(Props).concat(Object.keys(value)))\n\n    for (const k of keys) {\n      let v = value[k]\n      const p = path.concat(k)\n      const b = branch.concat(v)\n      const Prop = Props[k]\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k]\n      }\n\n      if (!(k in Props)) {\n        failures.push(\n          Struct.fail({\n            type: undefined,\n            value: v,\n            path: p,\n            branch: value,\n          })\n        )\n\n        continue\n      }\n\n      const [pfs, pr] = Prop.check(v, b, p)\n\n      if (pfs) {\n        failures.push(...pfs)\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport kindOf from 'kind-of'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createPartial = (\n  schema: {},\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'object',\n    `Partial structs must be defined as an object, but you passed: ${schema}`\n  )\n\n  const Props: Record<string, Struct> = {}\n\n  for (const key in schema) {\n    Props[key] = struct.union([schema[key], 'undefined'])\n  }\n\n  const Struct = createStruct({\n    kind: 'object',\n    type: `{${Object.keys(schema).join()}}`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const d = Struct.default()\n\n    if (value === undefined) {\n      value = d\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = {}\n    const failures: Failure[] = []\n\n    for (const k of value) {\n      let v = value[k]\n      const p = path.concat(k)\n      const b = branch.concat(v)\n      const Prop = Props[k]\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k]\n      }\n\n      if (!(k in Props)) {\n        failures.push(\n          Struct.fail({\n            type: undefined,\n            value: v,\n            path: p,\n            branch: value,\n          })\n        )\n\n        continue\n      }\n\n      const [pfs, pr] = Prop.check(v, b, p)\n\n      if (pfs) {\n        failures.push(...pfs)\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport kindOf from 'kind-of'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createPick = (\n  schema: {},\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'object',\n    `Pick structs must be defined as an object, but you passed: ${schema}`\n  )\n\n  const Props: Record<string, Struct> = {}\n\n  for (const key in schema) {\n    Props[key] = struct(schema[key])\n  }\n\n  const Struct = createStruct({\n    kind: 'pick',\n    type: `pick<{${Object.keys(schema).join()}}>`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const d = Struct.default()\n\n    if (value === undefined) {\n      value = d\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = {}\n    const failures: Failure[] = []\n\n    for (const k in Props) {\n      let v = value[k]\n      const p = path.concat(k)\n      const b = branch.concat(v)\n      const Prop = Props[k]\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k]\n      }\n\n      const [pfs, pr] = Prop.check(v, b, p)\n\n      if (pfs) {\n        failures.push(...pfs)\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport kindOf from 'kind-of'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createRecord = (\n  schema: [any, any],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) && schema.length === 2,\n    `Record structs must be defined as an array with two elements, but you passed: ${schema}`\n  )\n\n  const Key = struct(schema[0])\n  const Value = struct(schema[1])\n  const Struct = createStruct({\n    kind: 'record',\n    type: `record<${Key.type},${Value.type}>`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any,\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    // Record structs have a special default handling behavior, where the defaults\n    // are for the entries themselves, not for the entire value. So we can't use\n    // JavaScript's built-in default handling here.\n    const defs = Struct.default()\n    value = defs ? { ...defs, ...value } : value\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = {}\n    const failures: Failure[] = []\n\n    for (let k in value) {\n      const v = value[k]\n      const p = path.concat(k)\n      const b = branch.concat(v)\n      const [kfs, kr] = Key.check(k, b, p)\n\n      if (kfs) {\n        failures.push(...kfs)\n      } else {\n        const [vfs, vr] = Value.check(v, b, p)\n\n        if (vfs) {\n          failures.push(...vfs)\n        } else {\n          result[kr] = vr\n        }\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Struct, Superstruct } from '..'\n\nexport const createScalar = (\n  schema: string,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'string',\n    `Scalar structs must be defined as a string, but you passed: ${schema}`\n  )\n\n  const { Types } = struct\n\n  invariant(\n    schema in Types,\n    `No struct validator function found for type \"${schema}\".`\n  )\n\n  const Struct = struct(Types[schema], defaults)\n  Struct.kind = 'scalar'\n  Struct.type = schema\n  return Struct\n}\n","import { isStruct, Struct, Superstruct } from '..'\n\nexport const createShorthand = (\n  schema: any,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  if (isStruct(schema)) {\n    return schema\n  }\n\n  if (Array.isArray(schema)) {\n    if (schema.length === 1) {\n      const [first] = schema\n      return struct.array([first], defaults)\n    } else if (schema.length > 1) {\n      return struct.tuple(schema, defaults)\n    }\n  }\n\n  if (typeof schema === 'function') {\n    return struct.function(schema, defaults)\n  }\n\n  if (typeof schema === 'object') {\n    return struct.object(schema, defaults)\n  }\n\n  if (typeof schema === 'string') {\n    let optional = false\n    let Struct\n\n    if (schema.endsWith('?')) {\n      optional = true\n      schema = schema.slice(0, -1)\n    }\n\n    if (schema.includes('|')) {\n      const scalars = schema.split(/\\s*\\|\\s*/g)\n      Struct = struct.union(scalars, defaults)\n    } else if (schema.includes('&')) {\n      const scalars = schema.split(/\\s*&\\s*/g)\n      Struct = struct.intersection(scalars, defaults)\n    } else {\n      Struct = struct.scalar(schema, defaults)\n    }\n\n    if (optional) {\n      Struct = struct.union([Struct, 'undefined'], undefined)\n    }\n\n    return Struct\n  }\n\n  throw new Error(\n    `A schema definition must be an object, array, string or function, but you passed: ${schema}`\n  )\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createTuple = (\n  schema: any[],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema),\n    `Tuple structs must be defined as an array, but you passed: ${schema}`\n  )\n\n  const Elements = schema.map(s => struct(s))\n  const Struct = createStruct({\n    kind: 'tuple',\n    type: `[${Elements.map(S => S.type).join()}]`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    if (!Array.isArray(value)) {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = []\n    const failures: Failure[] = []\n    const length = Math.max(value.length, Elements.length)\n\n    for (let i = 0; i < length; i++) {\n      const Element = Elements[i]\n      const v = value[i]\n      const p = path.concat(i)\n      const b = branch.concat(v)\n\n      if (!Element) {\n        failures.push(\n          Struct.fail({ type: undefined, value: v, path: p, branch: b })\n        )\n      } else {\n        const [efs, er] = Element.check(v, b, p)\n\n        if (efs) {\n          failures.push(...efs)\n        } else {\n          result[i] = er\n        }\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { createStruct } from '../struct'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\n\nexport const createUnion = (\n  schema: any[],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) && schema.length !== 0,\n    `Union structs must be defined as a non-empty array, but you passed: ${schema}`\n  )\n\n  const Structs = schema.map(sch => struct(sch))\n  const type = Structs.map(s => s.type).join(' | ')\n  const Struct = createStruct({\n    kind: 'union',\n    type,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    for (const struct of Structs) {\n      const [fs, v] = struct.check(value, branch, path)\n\n      if (!fs) {\n        return [undefined, v]\n      }\n    }\n\n    return [[Struct.fail({ value, branch, path })]]\n  }\n\n  return Struct\n}\n","import { Validator, Types as BuiltinTypes } from './types'\nimport { Branch, Failure, Path, StructError } from './struct-error'\nimport { Struct } from './struct'\nimport {\n  createArray,\n  createDynamic,\n  createEnum,\n  createFunction,\n  createInstance,\n  createInterface,\n  createIntersection,\n  createLazy,\n  createLiteral,\n  createObject,\n  createPartial,\n  createPick,\n  createRecord,\n  createScalar,\n  createShorthand,\n  createSize,\n  createTuple,\n  createUnion,\n} from './structs'\n\n/**\n * `SuperstructSettings` are passed in when creating a `Superstruct` factory.\n */\n\nexport type SuperstructSettings = {\n  types: Record<string, Validator>\n  error: { new (failures: Failure[]): Error }\n}\n\n/**\n * Create a struct singleton with settings that include your own domain-specific\n * data `types`, and an optional custom `Error` class.\n */\n\nexport const superstruct = (\n  settings: Partial<SuperstructSettings> = {}\n): Superstruct => {\n  const struct = (schema: any, defaults?: any): Struct => {\n    return createShorthand(schema, defaults, struct)\n  }\n\n  struct.array = (schema: [any], defaults?: any): Struct => {\n    return createArray(schema, defaults, struct)\n  }\n\n  struct.dynamic = (\n    schema: (value: any, branch: Branch, path: Path) => Struct,\n    defaults?: any\n  ): Struct => {\n    return createDynamic(schema, defaults, struct)\n  }\n\n  struct.enum = (schema: any[], defaults?: any): Struct => {\n    return createEnum(schema, defaults, struct)\n  }\n\n  struct.function = (schema: Validator, defaults?: any): Struct => {\n    return createFunction(schema, defaults, struct)\n  }\n\n  struct.instance = (schema: any, defaults?: any): Struct => {\n    return createInstance(schema, defaults, struct)\n  }\n\n  struct.interface = (schema: any, defaults?: any): Struct => {\n    return createInterface(schema, defaults, struct)\n  }\n\n  struct.intersection = (schema: any[], defaults?: any): Struct => {\n    return createIntersection(schema, defaults, struct)\n  }\n\n  struct.lazy = (schema: () => Struct, defaults?: any): Struct => {\n    return createLazy(schema, defaults, struct)\n  }\n\n  struct.literal = (schema: any, defaults?: any): Struct => {\n    return createLiteral(schema, defaults, struct)\n  }\n\n  struct.object = (schema: {}, defaults?: any): Struct => {\n    return createObject(schema, defaults, struct)\n  }\n\n  struct.optional = (schema: any, defaults?: any): Struct => {\n    return createUnion([schema, 'undefined'], defaults, struct)\n  }\n\n  struct.partial = (schema: {}, defaults?: any): Struct => {\n    return createPartial(schema, defaults, struct)\n  }\n\n  struct.pick = (schema: {}, defaults?: any): Struct => {\n    return createPick(schema, defaults, struct)\n  }\n\n  struct.record = (schema: [any, any], defaults?: any): Struct => {\n    return createRecord(schema, defaults, struct)\n  }\n\n  struct.scalar = (schema: string, defaults?: any): Struct => {\n    return createScalar(schema, defaults, struct)\n  }\n\n  struct.size = (schema: [number, number], defaults?: any): Struct => {\n    return createSize(schema, defaults, struct)\n  }\n\n  struct.tuple = (schema: any[], defaults?: any): Struct => {\n    return createTuple(schema, defaults, struct)\n  }\n\n  struct.union = (schema: any[], defaults?: any): Struct => {\n    return createUnion(schema, defaults, struct)\n  }\n\n  struct.Error = settings.error || StructError\n  struct.Types = { ...BuiltinTypes, ...settings.types }\n  return struct\n}\n\n/**\n * `Superstruct` factories create different kinds of [[Struct]] validators, and\n * encapsulate the user-defined data types.\n *\n * The [[struct]] export is a factory that ships with Superstruct by default,\n * pre-configured with all of the built-in JavaScript data types. It's the\n * easiest way to quickly define structs:\n *\n * ```js\n * import { struct } from 'superstruct'\n *\n * const User = struct({\n *   id: 'number',\n *   name: 'string',\n * })\n * ```\n *\n * If you need to define custom data types, you can define your own by using\n * the [[superstruct]] export:\n *\n * ```js\n * import { superstruct } from 'superstruct'\n * import isEmail from 'is-email'\n * import isUrl from 'is-url'\n *\n * const struct = superstruct({\n *   types: {\n *     email: value => isEmail(value) && value.length < 256,\n *     url: value => isUrl(value) && value.length < 2048,\n *   }\n * })\n *\n * const User = struct({\n *   id: 'number',\n *   name: 'string',\n *   email: 'email',\n *   website: 'url?',\n * })\n * ```\n *\n * This way you can easily define structs that contain types like `'email'`,\n * `'url'`, or whatever else your application may need.\n */\n\nexport interface Superstruct {\n  /**\n   * Structs are defined by passing a schema definition to the struct factory.\n   * The schema definition can be a string, array, object or function. They can\n   * also be composed by nesting structs inside each other.\n   *\n   * The default struct factory allows you to write structs using a shorthand\n   * syntax for the most common cases—arrays, objects, scalars, tuples, etc.\n   *\n   * ```js\n   * struct('string') // Scalars\n   * struct(['number']) // Arrays\n   * struct({ name: 'string' }) // Objects\n   * struct(['error', 'string']) // Tuples\n   * struct('number?') // Optional\n   * struct('string & email') // Intersection\n   * struct('number | string') // Union\n   * struct(value => true || false) // Function\n   * struct(Struct) // Pass-through\n   * ```\n   *\n   * Each shorthand is equivalent to a method on the [[Superstruct]] factory:\n   *\n   * ```js\n   * // These are equivalent...\n   * struct(['number'])\n   * struct.array(['number'])\n   *\n   * struct('string & email')\n   * struct.union(['string', 'email'])\n   * ```\n   *\n   * And each one can use your custom types, or even other structs:\n   *\n   * ```js\n   * struct('email')\n   * struct(User)\n   * ```\n   *\n   * The second argument to struct factories is always a `defaults` value. It\n   * can either be the default itself or a function that returns the default.\n   *\n   * ```js\n   * struct('id', uuid.v4)\n   *\n   * struct({\n   *   id: 'number',\n   *   name: 'string',\n   *   is_admin: 'boolean?',\n   * }, {\n   *   is_admin: false,\n   * })\n   * ```\n   */\n\n  (schema: any, defaults?: any): Struct\n\n  /**\n   * Array structs validate that their input is an array with elements that\n   * match a specific struct. You can also pass the `max` or `min` options to\n   * validate the length of the array.\n   *\n   * ```js\n   * const Struct = struct.array(['number'])\n   *\n   * Struct([1, 2, 3])\n   * ```\n   *\n   * They are similar to the `Array` type in TypeScript.\n   */\n\n  array(schema: [any], defaults?: any): Struct\n\n  /**\n   * Dynamic structs are defined by a function that is passed the value being\n   * validated, and they determine which struct to use at runtime.\n   *\n   * ```js\n   * const Struct = struct.dynamic(value => StructA || StructB)\n   * ```\n   *\n   * They are inhernetly less performant that compile-time structs, but they\n   * unlock a set of possibilities that aren't possible at compile time alone.\n   */\n\n  dynamic(\n    schema: (value: any, branch: Branch, path: Path) => Struct,\n    defaults?: any\n  ): Struct\n\n  /**\n   * Enum structs validate that their input is one of a set of values.\n   *\n   * ```js\n   * const Struct = struct.enum(['fruit', 'vegetable', 'meat'])\n   *\n   * Struct('fruit')\n   * ```\n   *\n   * They are similar to the `enum` type in TypeScript.\n   */\n\n  enum(schema: any[], defaults?: any): Struct\n\n  /**\n   * Function structs validate their input against a one-off validator function.\n   *\n   * ```js\n   * const Struct = struct.function(value => typeof value === 'string')\n   *\n   * Struct('a simple string')\n   * ```\n   *\n   * They can't provide as detailed of errors as other struct types, but they do\n   * allow for customization for easy one-off cases.\n   */\n\n  function(schema: Validator, defaults?: any): Struct\n\n  /**\n   * Instance structs validate that their input is an instance of a class.\n   *\n   * ```js\n   * const Struct = struct.instance(MyClass)\n   *\n   * Struct(new MyClass())\n   * ```\n   */\n\n  instance(schema: any, defaults?: any): Struct\n\n  /**\n   * Interface structs validate that their input matches an interface defined as\n   * a set of properties with associated types.\n   *\n   * ```js\n   * const Struct = struct.interface({\n   *   length: 'number',\n   *   indexOf: 'function',\n   * })\n   *\n   * Struct([1, 2, 3])\n   * Struct('abc')\n   * ```\n   *\n   * They are similar to the structural-typing granted by TypeScript.\n   */\n\n  interface(schema: any, defaults?: any): Struct\n\n  /**\n   * Intersection structs validate that their input matches **all** of a set of\n   * different structs.\n   *\n   * ```js\n   * const Struct = struct.intersection('string & email')\n   *\n   * Struct('jane@example.com')\n   * ```\n   *\n   * Note: The structs will be validated in order, so validators on the right\n   * can rely on the validators before them having passed.\n   *\n   * They are similar to the `&` operator in TypeScript.\n   */\n\n  intersection(schema: any[], defaults?: any): Struct\n\n  /**\n   * Lazy structs allow you to initialize a struct lazily, only initializing it\n   * once on the first time it attempts to be validated.\n   *\n   * ```js\n   * const Struct = struct({\n   *   nodes: struct.lazy(() => Struct)\n   * })\n   *\n   * Struct({\n   *   nodes: {\n   *     nodes: { ... }\n   *   }\n   * })\n   * ```\n   *\n   * They are helpful for defining recursive structs.\n   */\n\n  lazy(schema: () => Struct, defaults?: any): Struct\n\n  /**\n   * Literal structs validate their input against a literal value.\n   *\n   * ```js\n   * const Struct = struct.literal(42)\n   *\n   * Struct(42)\n   * ```\n   */\n\n  literal(schema: any, defaults?: any): Struct\n\n  /**\n   * Object structs validate that their input exactly matches an object defined\n   * as a set of properties with associated types.\n   *\n   * ```js\n   * const Struct = struct.object({\n   *   id: 'number',\n   *   name: 'string',\n   * })\n   *\n   * Struct({\n   *   id: 1,\n   *   name: 'Jane Smith',\n   * })\n   * ```\n   *\n   * They are similar to the `?` qualifier in TypeScript.\n   */\n\n  object(schema: {}, defaults?: any): Struct\n\n  /**\n   * Optional structs validate that their input passes a specific struct, or\n   * `undefined`.\n   *\n   * ```js\n   * const Struct = struct.optional('string?')\n   *\n   * Struct('a string of text')\n   * Struct(undefined)\n   * ```\n   *\n   * This is a shorthand for using `struct.union` with `undefined`.\n   */\n\n  optional(schema: any, defaults?: any): Struct\n\n  /**\n   * Partial structs validate that their input partially matches an object\n   * defined as a set of properties with associated types. All of the properties\n   * of the object are optional.\n   *\n   * ```js\n   * const Struct = struct.partial({\n   *   id: 'number'\n   *   name: 'string',\n   * })\n   *\n   * Struct({\n   *   name: 'Jane Smith',\n   * })\n   * ```\n   *\n   * They are similar to the `Partial` utility in TypeScript.\n   */\n\n  partial(schema: {}, defaults?: any): Struct\n\n  /**\n   * Pick structs validate that their input exactly matches a subset of an\n   * object defined as a set of properties with associated types. All of the\n   * properties of its schema are required, but the object can have more that it\n   * does not concern itself with.\n   *\n   * ```js\n   * const Struct = struct.pick({\n   *   id: 'string',\n   *   name: 'string',\n   * })\n   *\n   * Struct({\n   *   id: 1,\n   *   name: 'James Smith',\n   *   email: 'james@example.com',\n   * })\n   * ```\n   *\n   * They are similar to the `Pick` utility in TypeScript.\n   */\n\n  pick(schema: {}, defaults?: any): Struct\n\n  /**\n   * Record structs validate that their input is an object with keys that match\n   * one struct and values that match another. The object can have zero or many\n   * properties set on it.\n   *\n   * ```js\n   * const Struct = struct.record('string', 'number')\n   *\n   * Struct({\n   *   a: 1,\n   *   b: 2,\n   * })\n   * ```\n   *\n   * They are similar to the `Record` utility in TypeScript.\n   */\n\n  record(schema: [any, any], defaults?: any): Struct\n\n  /**\n   * Scalar structs validate that their input passes the `Validator` function\n   * defined for a specific type by name. By default Superstruct ships with a\n   * set of built-in scalars. But you can configure it with custom scalars that\n   * match your domain.\n   *\n   * ```js\n   * const Struct = struct.scalar('string')\n   *\n   * Struct('a string of text')\n   * ```\n   */\n\n  scalar(schema: string, defaults?: any): Struct\n\n  /**\n   * Size structs validate their input has a certain length, by checking its\n   * `length` property. This works strings or arrays.\n   *\n   * ```js\n   * const Struct = struct.size([0, 7])\n   *\n   * Struct([1, 2, 3])\n   * Struct('abcdefg')\n   * ```\n   *\n   * They are helpful for defining unions with array structs.\n   */\n\n  size(schema: [number, number], defaults?: any): Struct\n\n  /**\n   * Tuple structs validate that their input exactly matches a tuple of values,\n   * in length and in type.\n   *\n   * ```js\n   * const Struct = struct.tuple(['string', 'boolean'])\n   *\n   * Struct(['one', true])\n   * ```\n   */\n\n  tuple(schema: any[], defaults?: any): Struct\n\n  /**\n   * Union structs validate that their input matches **at least one** of a set\n   * of different structs.\n   *\n   * ```js\n   * const Struct = struct.union(['string', 'number'])\n   *\n   * Struct('a string')\n   * Struct(42)\n   * ```\n   *\n   * They are similar to the `|` operator in TypeScript.\n   */\n\n  union(schema: any[], defaults?: any): Struct\n\n  /**\n   * The class for errors thrown by `Structs`, defaults to [[StructError]].\n   */\n\n  Error: { new (failures: Failure[]): Error }\n\n  /**\n   * The set of data types that the factory knows.\n   */\n\n  Types: Record<string, Validator>\n}\n","import { superstruct } from './superstruct'\n\n/**\n * The singleton instance of Superstruct that is exported by default, configured\n * with types for all of the JavaScript built-in data types.\n *\n * You can use it if you don't need any custom types. However, if you do want to\n * define custom types, use the [[superstruct]] factory to configure your own\n * [[Superstruct]] instance.\n */\n\nconst struct = superstruct()\n\nexport { struct, superstruct }\nexport { Superstruct } from './superstruct'\nexport { StructError, Failure, Path, Branch } from './struct-error'\nexport { Types, Validator } from './types'\nexport { isStruct, Struct } from './struct'\n"],"names":["Types","any","value","undefined","arguments","kindOf","array","boolean","buffer","date","isNaN","error","float32array","float64array","function","generatorfunction","int16array","int32array","int8array","map","null","number","object","promise","regexp","set","string","symbol","uint16array","uint32array","uint8array","uint8clampedarray","weakmap","weakset","StructError","failures","invariant","length","first","path","type","branch","rest","message","join","JSON","stringify","Object","assign","stack","Error","__proto__","prototype","TypeError","STRUCT","Symbol","isStruct","createStruct","props","struct","Struct","assert","defineProperty","kind","default","defaults","test","check","result","validate","fail","obj","createArray","schema","Array","isArray","Element","i","v","concat","efs","er","push","createDynamic","Dynamic","createEnum","validator","includes","s","createFunction","r","createInstance","name","createInterface","Props","key","keys","k","Prop","pfs","createIntersection","Structs","sch","fs","createLazy","Lazy","createSize","every","n","min","max","createLiteral","createObject","d","Set","p","b","pr","createPartial","union","createPick","createRecord","Key","Value","defs","kfs","kr","vfs","vr","createScalar","createShorthand","tuple","optional","endsWith","slice","scalars","split","intersection","scalar","createTuple","Elements","S","Math","createUnion","superstruct","settings","dynamic","enum","instance","interface","lazy","literal","partial","pick","record","size","BuiltinTypes","types"],"mappings":"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"}