import { Struct, StructType, StructContext } from './struct';
declare type StructRecord<T> = Record<string, Struct<T>>;
declare type StructTuple<T> = {
    [K in keyof T]: Struct<T[K]>;
};
/**
 * Validate any value.
 */
export declare function any(): Struct<any>;
/**
 * Validate that an array of values of a specific type.
 */
export declare function array<T>(Element: Struct<T>): Struct<T[]>;
/**
 * Validate that boolean values.
 */
export declare function boolean(): Struct<boolean>;
/**
 * Augment a `Struct` to add an additional coercion step to its input.
 */
export declare function coercion<T>(struct: Struct<T>, coercer: Struct<T>['coercer']): Struct<T>;
/**
 * Validate that `Date` values.
 *
 * Note: this also ensures that the value is *not* an invalid `Date` object,
 * which can occur when parsing a date fails but still returns a `Date`.
 */
export declare function date(): Struct<Date>;
/**
 * Augment a struct to coerce a default value for missing values.
 *
 * Note: You must use `coerce(value, Struct)` on the value before validating it
 * to have the value defaulted!
 */
export declare function defaulted<T>(S: Struct<T>, fallback: any, strict?: true): Struct<T>;
/**
 * Validate that a value dynamically, determing which struct to use at runtime.
 */
export declare function dynamic<T>(fn: (value: unknown, ctx: StructContext) => Struct<T>): Struct<T>;
/**
 * Validate that a value against a set of potential values.
 */
export declare function enums<T>(values: T[]): Struct<T>;
/**
 * Validate that a value is an instance of a class.
 */
export declare function instance<T extends {
    new (...args: any): any;
}>(Class: T): Struct<InstanceType<T>>;
/**
 * Validate that a value is an integer.
 */
export declare function integer(): Struct<number>;
/**
 * Validate that a value matches all of a set of structs.
 */
export declare function intersection<A>(Structs: StructTuple<[A]>): Struct<A>;
export declare function intersection<A, B>(Structs: StructTuple<[A, B]>): Struct<A & B>;
export declare function intersection<A, B, C>(Structs: StructTuple<[A, B, C]>): Struct<A & B & C>;
export declare function intersection<A, B, C, D>(Structs: StructTuple<[A, B, C, D]>): Struct<A & B & C & D>;
export declare function intersection<A, B, C, D, E>(Structs: StructTuple<[A, B, C, D, E]>): Struct<A & B & C & D & E>;
/**
 * Validate a value lazily, by constructing the struct right before the first
 * validation. This is useful for cases where you want to have self-referential
 * structs for nested data structures.
 */
export declare function lazy<T>(fn: () => Struct<T>): Struct<T>;
/**
 * Augment a string or array struct to constrain its length to being between a
 * minimum and maximum size.
 */
export declare function length<T extends string | any[]>(S: Struct<T>, min: number, max?: number): Struct<T>;
/**
 * Validate that a value is a specific constant.
 */
export declare function literal<T>(constant: T): Struct<T>;
/**
 * Validate that a value is a map with specific key and value entries.
 */
export declare function map<K, V>(Structs: StructTuple<[K, V]>): Struct<Map<K, V>>;
/**
 * Validate that a value always fails.
 */
export declare function never(): Struct<never>;
/**
 * Validate that a value is a number.
 */
export declare function number(): Struct<number>;
/**
 * Validate that an object with specific entry values.
 */
export declare function object<V extends StructRecord<any>>(Structs: V): Struct<{
    [K in keyof V]: StructType<V[K]>;
}>;
/**
 * Augment a struct to make it accept optionally accept `undefined` values.
 */
export declare function optional<T>(S: Struct<T>): Struct<T | undefined>;
/**
 * Validate that a partial object with specific entry values.
 */
export declare function partial<V extends StructRecord<any>>(Structs: V): Struct<{
    [K in keyof V]?: StructType<V[K]>;
}>;
/**
 * Refine a string struct to match a specific regexp pattern.
 */
export declare function pattern<T extends string>(S: Struct<T>, regexp: RegExp): Struct<T>;
/**
 * Validate that a value is a record with specific key and
 * value entries.
 */
export declare function record<K extends string | number, V>(Structs: StructTuple<[K, V]>): Struct<Record<K, V>>;
/**
 * Augment a `Struct` to add an additional refinement to the validation.
 */
export declare function refinement<T>(struct: Struct<T>, type: string, refiner: Struct<T>['refiner']): Struct<T>;
/**
 * Validate that a set of values matches a specific type.
 */
export declare function set<T>(Element: Struct<T>): Struct<Set<T>>;
/**
 * Validate that a value is a string.
 */
export declare function string(): Struct<string>;
/**
 * Coerce a string value to ensure it is trimmed.
 */
export declare function trimmed<T extends string>(S: Struct<T>): Struct<T>;
/**
 * Validate that a value is a tuple with entries of specific types.
 */
export declare function tuple<A>(Elements: StructTuple<[A]>): Struct<[A]>;
export declare function tuple<A, B>(Elements: StructTuple<[A, B]>): Struct<[A, B]>;
export declare function tuple<A, B, C>(Elements: StructTuple<[A, B, C]>): Struct<[A, B, C]>;
export declare function tuple<A, B, C, D>(Elements: StructTuple<[A, B, C, D]>): Struct<[A, B, C, D]>;
export declare function tuple<A, B, C, D, E>(Elements: StructTuple<[A, B, C, D, E]>): Struct<[A, B, C, D, E]>;
/**
 * Validate that a value matches a specific strutural interface, like the
 * structural typing that TypeScript uses.
 */
export declare function type<V extends StructRecord<any>>(Structs: V): Struct<{
    [K in keyof V]: StructType<V[K]>;
}>;
/**
 * Validate an unknown value, accepting anything but not narrowing the type.
 */
export declare function unknown(): Struct<unknown>;
/**
 * Validate that a value is one of a set of types.
 */
export declare function union<A>(Structs: StructTuple<[A]>): Struct<A>;
export declare function union<A, B>(Structs: StructTuple<[A, B]>): Struct<A | B>;
export declare function union<A, B, C>(Structs: StructTuple<[A, B, C]>): Struct<A | B | C>;
export declare function union<A, B, C, D>(Structs: StructTuple<[A, B, C, D]>): Struct<A | B | C | D>;
export declare function union<A, B, C, D, E>(Structs: StructTuple<[A, B, C, D, E]>): Struct<A | B | C | D | E>;
export {};
